## [排序](https://zhuanlan.zhihu.com/p/122293204)

### 冒泡排序

#### 实现逻辑

1. 依次比较相邻的两个元素，进行交换
2. 循环冒泡，次数为数据个数-1

#### 动图演示
![冒泡排序](../Texture/%E7%AE%97%E6%B3%95/BubbleSort.gif)


#### 代码实现

```c#
private List<int> mNumList = new List<int>() { 1, 5, 6, 5, 8, 2, 1, 3, 4, 9 };

void Start()
{
	Sort();
}

private void Sort()
{
	for (int i = 0; i < mNumList.Count - 1; i++)
	{
    	for (int j = 0; j < mNumList.Count - 1 - i; j++)
		{
			if (mNumList[j] < mNumList[j + 1])  //依次比较相邻的两个元素，进行交换
			{
				int temp = mNumList[j];
				mNumList[j] = mNumList[j + 1];
				mNumList[j + 1] = temp;
			}
		}
	}
}
```

#### 性能分析

- 平均时间复杂度：O(N^2)
- 最佳时间复杂度：O(N)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 排序方式：In-place

#### 算法优化改进

##### 改进方法①

`场景分析`：

在某次遍历中如果没有数据交换，说明整个数组已经有序。若初始序列就是排序好的，如果用基础的冒泡排序方法，仍然还要比较O(N^2)次，但无交换次数。

`改进思路`：

**通过设置标志位来记录此次遍历有无数据交换，进而可以判断是否要继续循环，设置一个flag标记，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变**。

改进代码：

```cpp
public class 冒泡排序改进_A : MonoBehaviour
{
    private List<int> numList = new List<int>() { 9, 7, 8, 6, 5, 4, 3, 2, 1, 0 };
    private int count = 0;

    void Start()
    {
        Sort();

        string sortStr = "";
        for (int i = 0; i < numList.Count; i++)
        {
            sortStr += numList[i] + "、";
        }
        Debug.Log($"改进A次数:{count}。{sortStr}");
    }

    private void Sort()
    {
        for (int i = 0; i < numList.Count - 1; i++)
        {
            bool exchange = true;  //冒泡的改进，若在一趟中没有发生逆序，则该序列已有序

            for (int j = 0; j < numList.Count - 1 - i; j++)
            {
                if (numList[j] < numList[j + 1])
                {
                    int temp = numList[j];
                    numList[j] = numList[j + 1];
                    numList[j + 1] = temp;

                    exchange = false;
                }
                count++;
            }
            if (exchange)
            {
                return;
            }
        }
    }
}
```

##### 改进方法②

`场景分析`：

如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了。

`改进思路`：

**记录某次遍历时最后发生数据交换的位置pos，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可**。

改进代码：

```c#
public class 冒泡排序改进_B : MonoBehaviour
{
    private int[] numList = { 23, 5, 7, 1, 9, 15, 18, 3, 4, 6, 11, 12, 13, 14, 16, 17, 19, 20 }; // 示例数组
    private int count = 0;

    void Start()
    {
        Sort();

        string sortStr = "";
        for (int i = 0; i < numList.Length; i++)
        {
            sortStr += numList[i] + "、";
        }
        Debug.Log($"改进B次数:{count}。{sortStr}");
    }

    void Sort()
    {
        int lastExchangeIndex = numList.Length - 1; // 初始化最后交换的位置为数组末尾

        while (lastExchangeIndex > 0)
        {
            int newLastExchangeIndex = 0; // 每次循环开始前，重置最后交换的位置

            for (int i = 0; i < lastExchangeIndex; i++)
            {
                if (numList[i] > numList[i + 1])
                {
                    // 交换元素
                    int temp = numList[i];
                    numList[i] = numList[i + 1];
                    numList[i + 1] = temp;

                    // 更新最后交换的位置
                    newLastExchangeIndex = i;
                }
                count++;
            }

            // 更新扫描范围
            lastExchangeIndex = newLastExchangeIndex;
        }
    }
}
```

#### 总结

冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，建议采用其它排序方法

------



### 快速排序

#### 实现逻辑

1. `选择基准元素`： 从数组中选择一个基准元素，通常是数组的第一个或最后一个元素。
2. `分割数组`： 将数组中小于基准元素的元素移到基准元素的左边，大于基准元素的元素移到基准元素的右边。这个过程称为分割。
3. `递归排序`： 对基准元素左边和右边的子数组进行递归地快速排序。
4. `合并`： 已经有序

#### 动图演示

![](E:\Gitee\Document\Texture\算法\QuickSork.jpg)

#### 代码实现

```c#
public class 快速排序 : MonoBehaviour
{
    private List<int> list = new List<int>() { 10, 3, 55, 8, 22, 71, 18, 23 };

    void Start()
    {
        Sort(list, 0, list.Count - 1);

        string sortStr = "";
        for (int i = 0; i < list.Count; i++)
        {
            sortStr += list[i] + "、";
        }
        Debug.Log($"快排:{sortStr}");
    }

    public void Sort(List<int> list, int Start, int End)
    {
        if (End - Start < 1) return;

        int mid = list[Start]; // 选择基准元素
        int s = Start; int e = End;
        while (s < e) // s=e 结束循环
        {
            while (s < e && mid <= list[e])
                e--;
            list[s] = list[e]; // 小于基准元素的元素移到基准元素的左边

            while (s < e && list[s] < mid)
                s++;
            list[e] = list[s]; // 大于基准元素的元素移到基准元素的右边
        }
        list[s] = mid; // s=e时放入基准元素

        // 递归排序
        Sort(list, Start, s - 1);
        Sort(list, s + 1, End);
    }
}
```

#### 性能分析

- 平均时间复杂度：O(NlogN)
- 最佳时间复杂度：O(NlogN)
- 最差时间复杂度：O(N^2)
- 空间复杂度：根据实现方式的不同而不同

#### 算法优化改进

`场景分析`： 递归是一种使用相同的方法，通过解决问题的子集以达到解决整个问题的方法，是一种使用有限代码解决“无限”计算的方法。在C/C++语言中递归表现在函数对自身的直接/间接的调用上，在实现上，递归依赖于语言的运行时调用堆栈，使用堆栈来保存每一次递归调用返回时所需要的条件。递归通常具有简洁的编码和清晰的思路，但这种简洁是有代价的。一方面，是函数调用的负担；另一方面，是堆栈占用的负担（堆栈的大小是有限的）。

`改进思路`：**递归转化为迭代。迭代的思想主要在于，在同一栈帧中不断使用现有数据计算出新的数据，然后使用新的数据来替换原有数据。**

```c#
public class 快速排序_迭代 : MonoBehaviour
{
    private List<int> list = new List<int>() { 10, 3, 55, 8, 22, 71, 18, 23 };

    void Start()
    {
        Sort(list);

        string sortStr = "";
        for (int i = 0; i < list.Count; i++)
        {
            sortStr += list[i] + "、";
        }
        Debug.Log($"快排_迭代:{sortStr}");
    }

    public void Sort(List<int> list)
    {
        Stack<(int Start, int End)> stack = new Stack<(int, int)>();
        stack.Push((0, list.Count - 1));

        while (stack.Count > 0)
        {
            var (Start, End) = stack.Pop(); // 移除并返回栈顶的元素
            if (End - Start < 1) continue;

            int mid = list[Start]; // 选择基准元素
            int s = Start, e = End;

            while (s < e)
            {
                while (s < e && mid <= list[e])
                    e--;
                list[s] = list[e];

                while (s < e && list[s] < mid)
                    s++;
                list[e] = list[s];
            }
            list[s] = mid; // s=e时放入基准元素

            // 将新的区间推入栈中
            stack.Push((Start, s - 1)); // 左区间
            stack.Push((s + 1, End)); // 右区间
        }
    }
}
```

#### 总结

快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，很多面试题中也经常遇到。对于其算法的改进，除了刚刚上文中提到的意外，根据实际场景还有诸多改进方法，包括**对小序列采用插入排序替代，三平均划分，三分区划分等改进方法**

------



### 插入排序

![](E:\Gitee\Document\Texture\算法\InsertSort.png)

#### 实现逻辑

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

#### 动图演示

![](E:\Gitee\Document\Texture\算法\InsertSort.gif)

#### 代码实现

```c#
private List<int> mNumList = new List<int>() { 1, 5, 6, 5, 8, 2, 1, 3, 4, 9 };

void Start()
{
	Sort();
}

private void Sort()
{
	for (int i = 1; i < mNumList.Count; i++)
	{
		int temp = mNumList[i]，j;
		for (j = i - 1; j >= 0; j--) // 遍历排在此数前面的数
		{
			if (mNumList[j] > temp) // 如果前面的一个数大于此数,交换位置,直到前面数比此数小为止
			{
				mNumList[j + 1] = mNumList[j];
			}
			else
			{
				break;
			}
		}
        mNumList[j + 1] = temp;
	}
}
```

#### 性能分析

- 平均时间复杂度：O(N^2)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：稳定

如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：

`最好情况`：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。
`最坏情况`：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。

#### 算法优化改进

##### 改进方法①

`场景分析`：

直接插入排序每次往前插入时，是按顺序依次往前查找，数据量较大时，必然比较耗时，效率低。

**改进思路： 在往前找合适的插入位置时采用二分查找的方式，即折半插入**

二分插入排序相对直接插入排序而言：平均性能更快，**时间复杂度降至O(NlogN)**，排序是稳定的，但排序的比较次数与初始序列无关，相比直接插入排序，在速度上有一定提升。逻辑步骤：

> ① 从第一个元素开始，该元素可以认为已经被排序
> ② 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置
> ③将新元素插入到该位置后
> ④ 重复上述两步

改进代码：

```cpp
// 插入排序改进：二分插入排序
void BinaryInsertSort(int arr[], int len)   
{   
    int key, left, right, middle;   
    for (int i=1; i<len; i++)   
    {   
        key = a[i];   
        left = 0;   
        right = i-1;   
        while (left<=right)   
        {   
            middle = (left+right)/2;   
            if (a[middle]>key)   
                right = middle-1;   
            else   
                left = middle+1;   
        }   

        for(int j=i-1; j>=left; j--)   
        {   
            a[j+1] = a[j];   
        }   

        a[left] = key;          
    }   
}
```

##### 改进方法②

`场景分析`：

(1) 插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。

(2) 插入排序在每次往前插入时只能将数据移动一位，效率比较低。

`改进思路`：

1. 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序
2. 然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时
3. 再对全体元素进行一次直接插入排序

改进思路二的方法实际上就是希尔排序。在这里只给出思路，在后续系列《算法：排序算法之希尔排序》中再做具体讲解说明。

#### 总结

插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。尤其当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率。 在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。

------



### 选择排序

冒泡排序每次都会发生交换，选择排序是一轮结束再交换

#### 基本思想

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置

#### 实现逻辑

1. 第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换
2. 第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换
3. 依次类推下去…

#### 动图演示

![](E:\Gitee\Document\Texture\算法\SelectionSort.webp)

**注**：*红色表示当前最小值，黄色表示已排序序列，绿色表示当前位置*

具体的我们以一组无序数列｛20，40，30，10，60，50｝为例分解说明，如下图所示：

![](E:\Gitee\Document\Texture\算法\SelectionSortTex.webp)

#### **复杂度分析**

- 平均时间复杂度：O(N^2)
- 最佳时间复杂度：O(N^2)
- 最差时间复杂度：O(N^2)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

选择排序的交换操作介于和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。

比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N = (n-1) + (n-2) +…+ 1 = n x (n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。

#### 代码实现

```c#
private List<int> mNumList = new List<int>() { 1, 5, 6, 5, 8, 2, 1, 3, 4, 9 };

void Start()
{
    Sort();
}

private void Sort()
{
    for (int i = 0; i < mNumList.Count - 1; i++)
    {
        int min = i;
        //每轮需要比较的次数n-i
        for (int j = i + 1; j < mNumList.Count; j++)
        {
            if (mNumList[min] > mNumList[j]) // 当此数大于后一个数
            {
                // 记录目前能找到的最小值元素的下标
                min = j;
            }
        }
        int temp = mNumList[i];
        mNumList[i] = mNumList[min];
        mNumList[min] = temp;
    }
}
```

####  优化改进

##### 二元选择排序

`改进思路`： 简单选择排序，每趟循环只能确定一个元素排序后的定位。根据之前冒泡排序的经验，我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。

##### 堆排序

堆排序是一种树形选择排序，是对直接选择排序的有效改进。具体的分析我们留到后面讲堆排序时再详细说明。

#### 总结

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

------



### 希尔排序

希尔排序的实质就是分组插入排序

####  基本思想

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

#### 实现逻辑

1. **确定增量序列：** 选择一个增量序列，通常取 n/2,n/4,n/8,…*n*/2,*n*/4,*n*/8,… 直到增量为1。
2. **分组排序：** 将数组分为若干个子序列，每个子序列包含相隔增量的元素。对每个子序列进行插入排序。
3. **缩小增量：** 重复上述步骤，逐渐减小增量，直到增量为1。

#### 动图演示

![](E:\Gitee\Document\Texture\算法\Shell Sort.webp)

具体我们以一组数字来说操作说明：

![](E:\Gitee\Document\Texture\算法\Shell SortTex.webp)

假设有一组｛9, 1, 2, 5, 7, 4, 8, 6, 3, 5｝无需序列。

> **第一趟排序**： 设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。
> **第二趟排序**：
> 将上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为2组。按照直接插入排序的方法对每个组进行排序。
> **第三趟排序**：
> 再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为1的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。

*注：需要注意一下的是，图中有两个相等数值的元素5和5。我们可以清楚的看到，在排序过程中，两个元素位置交换了。*

####  性能分析

> - 平均时间复杂度：O(Nlog2N)
> - 最佳时间复杂度：
> - 最差时间复杂度：O(N^2)
> - 空间复杂度：O(1)
> - 稳定性：不稳定
> - 复杂性：较复杂

希尔排序的效率取决于增量值gap的选取，时间复杂度并不是一个定值。

开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。

最优的空间复杂度为开始元素已排序，则空间复杂度为 0；最差的空间复杂度为开始元素为逆排序，则空间复杂度为 O(N);平均的空间复杂度为O(1)希尔排序并不只是相邻元素的比较，有许多跳跃式的比较，难免会出现相同元素之间的相对位置发生变化。比如上面的例子中希尔排序中相等数据5就交换了位置，所以希尔排序是不稳定的算法。

#### 代码实现

```C#
private List<int> mNumList = new List<int>() { 1, 5, 6, 5, 8, 2, 1, 3, 4, 9 };

void Start()
{
    Sort();
}

private void Sort()
{
    // 将每组间隔为h的分组进行排序，刚开始h=数组长度的一半
    for (int h = mNumList.Count / 2; h > 0; h /= 2)
    {
        //对每组进行插入排序
        for (int i = h; i < mNumList.Count; i++)
        {
            // 将numlist[i]插入到所在分组的正确位置上
            insertI(mNumList, h, i);
        }
    }
}

private static void insertI(List<int> arr, int h, int i)
{
    int temp = arr[i];
    int k;
    for (k = i - h; k >= 0 && temp < arr[k]; k -= h)
    {
        arr[k + h] = arr[k];
    }
    arr[k + h] = temp;
}
```

#### 重点说明(步( 摘录自wiki百科)

##### 步长序列

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。

作者最初的建议是折半再折半知道最后的步长为1<也就是插入排序>,虽然这样取可以比O(n2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如, 如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。

##### 常见步长序列

> ①步长序列：n/2i 最坏情况复杂度：O(n2)
> ②步长序列：2k-1 最坏情况复杂度：O(n3/2)
> ③步长序列：2i3j 最坏情况复杂度：O(nlog2n)

**注意**：由于显示特殊符号存在问题，步长序列中i、k-1，j等都是右上标符号。*

已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自9 x 4i – 9 x 2i + 1 和 2i+2 x (2i+2 -3)这两个算式。(注意：公众号里面无法显示特殊符号，两个公式中i，j等都是右上标符号)

#### 总结

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，交换不相邻的元素以对数组的局部进行排序，最终用插入排序将局部有序的数组排序。

希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。





## 斐波那契数列任意一位的值

```c#
static int Fn(int n)
{
	if (n <= 0)
	{
		throw new ArgumentOutOfRangeException();
	}
    if (n == 1||n==2) 
    {
    	return 1; 
    }
	return checked(Fn(n - 1) + Fn(n - 2)); // when n>46 memory will overflow
}
```



## 常用的数据结构

数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。 常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等。

### 数组理解

数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。 int[] data = new int[100]；data[0] = 1;

`优点：`

- 按照索引查询元素速度快

- 按照索引遍历数组方便

`缺点：`

-  数组的大小固定后就无法扩容了
-  数组只能存储一种类型的数据

-  添加，删除的操作慢，因为要移动其他的元素

-  适用场景： 频繁查询，对存储空间要求不大，很少增加和删除的情况。


### List理解

有序的对象列表，属于数据结构的一种：顺序结构。 

泛型集合类，引入System.Collections.Generic命名空间，常用操作有Count属性查看长度，Add()添加，Remove()去除，AddRange()添加集合，Clear()清空集合。

**数组和List的核心区别**

数组在C#中最早出现的。在内存中是连续存储的，所以它的索引速度非常快，而且赋值与修改元素也很简单。数组存在一些不足的地方。在数组的两个数据间插入数据是很麻烦的，而且在声明数组的时候必须指定数组的长度，数组的长度过长，会造成内存浪费，过段会造成数据溢出的错误。如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。**List<T>是集合，集合元素的数量可以动态变化**。增加、插入、删除元素很方便。

### 栈的理解

栈是一种特殊的**线性表**，仅能在**线性表的一端操作**，栈顶允许操作，栈底不允许操作。 栈的特点是：**先进后出**，从栈顶放入元素的操作叫入栈，取出元素叫出栈。 栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。

### 队列的理解

队列与栈一样，也是一种**线性表**，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：**先进先出**。从一端放入元素的操作称为入队，取出元素为出队。使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。

### 链表的理解

链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

`优点`

- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；

- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；


`缺点`

- 因为含有大量的指针域，占用空间较大；

- 查找元素需要遍历链表来查找，非常耗时。


`适用场景`

- 数据量较小，需要频繁增加，删除操作的场景


### 树的理解

树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；

- 没有父节点的节点称为根节点；

- 每一个非根节点有且只有一个父节点；

- 除了根节点外，每个子节点可以分为多个不相交的子树；

`二叉树`具有如下特点：

- 每个结点最多有两颗子树，结点的度最大为2。
- 左子树和右子树是有顺序的，次序不能颠倒。
- 即使某结点只有一个子树，也要区分左右子树。

**二叉树的所有遍历方式的原理及优缺点**

- 前序遍历，先访问根节点在访问左节点在访问右节点。

- 中序遍历，先访问左节点在访问根节点在访问右节点。

- 后序遍历，先访问左节点在访问右节点在访问根节点。


前中后代表的是访问根节点的时序。采用递归方式和非递归方式。前者优点是直观，编写起来简单，缺点是但其开销也比较大。非递归形式开销小，但编写复杂

### 散列表的理解

散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。

### 堆的理解

堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：

- 堆中某个节点的值总是不大于或不小于其父节点的值；

- 堆总是一棵完全二叉树；

- 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。


因为堆有序的特点，一般用来做数组中的排序，称为堆排序。

### 图的理解

图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 按照顶点指向的方向可分为无向图和有向图： 图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。


