#### 如何优化内存

- 压缩自带类库；
- 将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；
- 释放AssetBundle占用的资源；
- 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；
- 使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)
- 代码中少产生临时变量
- 警惕配置表的内存占用
- 检查ShaderLab内存占用
- 避免使用Standard材质，做好相应的variant skip.
- 排查项目冗余的Shader.
- 使用shader_feature替代multi_compile,这样只会收集项目里真正使用的变体组合，避免变体翻倍.
- 检查纹理资源的尺寸、格式、压缩方式、mipmap、Read & Write选项使用是否合理.
- 检查Mesh资源的Read & Write选项、顶点属性使用是否合理. 代码级别的检查，如Cache预分配空间、容器的Capacity、GC等.
- 使用Profiler定位下GC，特别是Update类函数里的. 如：字符串拼接、滥用容器等.
- 合理控制RenderTexture的尺寸. 优化动画Animation的压缩方式、浮点精度、去除里面的Scale曲线数据.
- 减少场景GameObject节点的数量,最好支持工具监控.



#### UI优化小知识

- 将同一画面图片放到同一图集中

- 图片和文字尽量不要交叉，会产生多余drawcall（相同材质和纹理的UI元素是可以合并的）

- UI层级尽量不要重叠太多

- 取消勾选不必要的射线检测RaycastTarget
- 将动态的UI元素和静态的UI元素放在不同的Canvas中，减少canvas网格重构频率



#### 在移动设备上的⼀些优化资源的方法

1. **纹理优化**：通过压缩纹理和使用图集减少内存和`draw call`。
2. **内存管理**：按需加载和卸载资源，使用Asset Bundles和Addressables管理资源。
3. **模型和网格优化**：减少多边形数，使用LOD和静态合并来减少渲染负担。
4. 减少骨骼数量
5. **音频优化**：压缩音频文件大小，使用流式加载。
6. **UI优化**：使用UI批处理、简化UI层级结构、避免频繁修改UI
7. **计算优化**：减少每帧计算量，优化物理计算。
8. 优化碰撞体、调节物理计算频率
9. 避免过多的实时阴影、优化阴影分辨率
10. **图形优化**：减少实时阴影和高成本后处理特效。
11. **网络优化**：压缩数据，减少网络请求频率。
12. 使⽤assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新
13. 顶点数对渲染⽆论是cpu还是gpu都是压⼒最⼤的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右
14. 只使⽤⼀盏动态光，不是⽤阴影，不使⽤光照探头 粒⼦系统是cpu上的⼤头
15. 剪裁粒⼦系统
16. 合并同时出现的粒⼦系统
17. ⾃⼰实现轻量级的粒⼦系统 animator也是⼀个效率奇差的地⽅
18. 把不需要跟⻣骼动画和动作过渡的地⽅全部使⽤ animation，控制⻣骼数ᰁ在30根以下
19. animator出视野不更新
20. 删除⽆意义的animator
21. animator的初始化很耗时（粒⼦上能不能尽ᰁ不⽤ animator）
22. 除主⻆外都不要跟⻣骼运动apply root motion
23. 绝对禁⽌掉那些不带刚体带包围盒的物体（static collider ）运动 NUGI的代码效率很差，基本上runtime的时候对cpu的 贡献和render不相上下
24. 每帧递归的计算finalalpha改为只有初始化和变动时 计算
25. 去掉法线计算
26. 不要每帧计算viewsize 和windowsize
27. filldrawcall时构建顶点缓存使⽤array.copy
28. 代码剪裁：使⽤strip level ，使⽤.net2.0 subset
29. 尽量减少smooth group
30. 给美术定⼀个严格的经过科学验证的美术标准，并在U3D⾥⾯配以相应的检查⼯具



#### CPU端性能优化小知识点

1. 逻辑和表现尽可能分离开，这样逻辑层的更新频率可以适当降低些.
2. 对于一些热点函数，如mono的实体更新、实例化，使用分帧处理，分摊单帧时间消耗.
3. 做好同屏实体数量、特效数量、距离显隐等优化.
4. 完善日志输出，避免没必要的日志输出，同时警惕日志字符串拼接.
5. 使用骨骼烘焙 + GPUSkinning + Instance 降低CPU蒙皮骨骼消耗和drawcall.
6. 开启模型的Optimize GameObjects减少节点数量和蒙皮更新消耗.
7. UI拼预制做好动静分离，对于像血条名字这种频繁变动的ui，做好适当的分组.
8. 减少C#和lua的频繁交互，尽量精简两者传递的参数结构.
9. 使用stringbuilder优化字符串拼接的gc问题.
10. 删除非必要的脚本功能函数，特别是Update/LateUpdate类高频执行函数，因为会产生C++到C#层的调用开销. 对于Update里需要用到的组件、节点等提前Cache好.

11. 场景里频繁使用的资源或数据结构做好资源复用和对象池.
12. 对于频繁显示隐藏的UI，可以先移出到屏幕外，如果长时间不显示再进行Deactive.
13. 合理拆分UI图集，区分共用图集和非共用图集，共用图集可以常驻内存，非共用图集优先按功能分类,避免资源冗余. 使用IL2CPP, 编译成C++版本能极大的提升整体性能.
14. 避免直接使用Material.Setxxx/Getxxx 等调用，这些调用会触发材质实例化消耗，可以考虑使用 SharedMaterial / MaterialPropertyBlock代替.
15. 合并Shader里的Uniform变量.



#### GPU端性能优化小知识点

1. 合理规划好渲染顺序，避免不必要的overdraw，如:地形（容易被其他物件遮挡）、天空盒放到较后渲染.

2. 分辨率缩放,对于填充率出现瓶颈时，这个是最简单高效的.

3. 避免使用GrabPass抓屏，不是所有硬件都支持，加之数据回拷和没法控制分辨率性能很差，可考虑使用CommandBuffer.blit去优化.

4. 控制好地形的Blend层数，控制在4层以内，考虑到地形一般屏占面积大、贴图采样次数多，对于中低画质考虑不用normalmap.

5. 做好物件、树、角色的LOD.

6. 避免使用RenderWithShader类方式来定制DepthTexture,可以考虑Camera的 public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer);进行优化.

7. 检查Shader的VertexInput 和 VertexOutput是否存在冗余数据.如:顶点色、多套UV.

8. 警惕项目里非必要的双面材质，对于需要局部双面的地方通过加面解决.

9. Shader里使用fixed、half代替float，理论上除position、uv、一些涉及depth相关计算使用float外，其他都应该使用fixed（主要是颜色值）、half.

10. 对于角色皮肤这种不是特别明显的效果，考虑使用预积分这种低成本的方案.

11. 对于frag里的计算过程，如果可以抽出来放到CPU应用层、顶点阶段的优先放这里计算. 需要注意放到顶点阶段引起的平滑过渡问题. 如: eyeVec导致高光过渡问题.

12. 镜面反射类效果避免使用反射相机+RT的实现，考虑使用SSR、CubeMap类实现.

13. 避免使用实时阴影，如若使用要合理控制下分辨率和阴影距离. 考虑使用Projector.

14. 使用统一的后处理框架代替多个Image Effect，可以共用模糊函数，减少blit操作. 另外Unity自带的Postprocessing V2 支持Volume，性能还是不错的.

15. Shader里避免使用分支、循环，sin、tan、pow、log等复杂数学运算.

16. Unity自带的遮挡剔除因为CPU消耗和内存占用较高，加之不能Instancing，不太适合移动平台，可以考虑静态预计算(缺点是不支持动态物体)、Hi-Z等优化方案.

17. 减少alpha test材质的使用，如若使用注意减小面积、控制渲染顺序.



#### **使用UGUI实现滚动列表时如何优化性能**

1. 对象池
2. 异步加载
3. 只渲染可见项
4. 尽量减少图形重叠
5. 使用合适的布局组件
6. 减少透明对象的使用
7. 硬件加速
8. 避免频繁的布局重新计算
9. 使用UI批处理，确保使用相同材质的元素，并尽量避免频繁的材质切换
10. 使用Profiler进行性能分析