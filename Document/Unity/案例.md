#### 空间内一物体绕球面固定点（0、1、2）按照固定速度speed环绕运动。

```csharp
public float Speed = 1;
void Update ()
{
    transform.RotateAround (new Vector3(0,1,2),Vector3.up,Speed);
}
```



#### 用代码实现第三角色控制器

```csharp
public class Player : MonoBehaviour
{
    public Transform _cameraTrans;
    private Vector3 _cameraOffset;
    void Awake()
    {
        _cameraOffset = transform.position - _cameraTrans.position;
    }
    void Update()
    {
        _cameraTrans.position = transform.position - _cameraOffset;
    }
}
```



#### 写一个计时器工具，从整点开始计时，格式为：00:00:00

```csharp
private float timer = 0f;
private int h = 0;
private int m = 0;
private int s = 0;
private string timeStr = string.Empty;
void Update ()
{
	timer += Time.deltaTime;
    if (timer >= 1f) {s++;  timer = 0;}
    if (s >= 60) {m++;s = 0;}
	if (m >= 60) {h++;m = 0;}
    if (h >= 99) {h = 0;}
}
void OnGUI()
{
	timeStr = string.Format ("{0:D2}:{1:D2}:{2:D2}", h, m, s);
    GUI.Label (new Rect (10, 10, 100, 200), timeStr);
}
```



#### 用鼠标实现在场景中拖动物体，用鼠标滚轮实现缩放(用一个Cube 即可)。

在场景中添加一个Plan，Camera，Directional Light，Cube。添加两个脚本scrollerScirpt（挂在Camera），CubeDragScript（挂在Cube上）。

##### 鼠标滚轮实现缩放：

将摄像机的镜头拉近或者拉远，调整摄像机的视角就可以实现，主要实现代码如下：

```csharp
void Update ()
{
     //鼠标滚轮的效果
     if (Input.GetAxis("Mouse ScrollWheel") < 0)
     {
          if (Camera.main.fieldOfView <= 100)
               Camera.main.fieldOfView += 2;
          if (Camera.main.orthographicSize <= 20)
               Camera.main.orthographicSize += 0.5F;
     }
     if (Input.GetAxis("Mouse ScrollWheel") > 0)
     {
          if (Camera.main.fieldOfView > 2)
               Camera.main.fieldOfView -= 2;
          if (Camera.main.orthographicSize >= 1)
               Camera.main.orthographicSize -= 0.5F;
     }
}
```

##### 鼠标实现在场景中拖动物体

　　解决思路就是将世界坐标转换成屏幕坐标，然后计算物体与鼠标之间移动量，循环鼠标被按下操作，得到鼠标的当前位置，加上计算好的移动量，将新的坐标赋值给物理就行了。主要是开启一个协同程序（Corountine）来处理。主要代码如下：

```c#
void Start ()
{
     StartCoroutine(OnMouseDown());
} 
IEnumerator OnMouseDown()
{
     //将物体由世界坐标系转换为屏幕坐标系
     Vector3 screenSpace = Camera.main.WorldToScreenPoint(transform.position);
     //完成两个步骤 1.由于鼠标的坐标系是2维，需要转换成3维的世界坐标系 
     //2.只有3维坐标情况下才能来计算鼠标位置与物理的距离，offset即是距离
     //将鼠标屏幕坐标转为三维坐标，再算出物体位置与鼠标之间的距离
     Vector3 offset = transform.position - Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenSpace.z));
     while (Input.GetMouseButton(0))
    {
          //得到现在鼠标的2维坐标系位置
          Vector3 curScreenSpace = new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenSpace.z);
          //将当前鼠标的2维位置转换成3维位置，再加上鼠标的移动量
          Vector3 curPosition = Camera.main.ScreenToWorldPoint(curScreenSpace) + offset;
          //curPosition就是物体应该的移动向量赋给transform的position属性
          transform.position = curPosition;
          yield return new WaitForFixedUpdate(); //这个很重要，循环执行
     }
}
```



#### NGUI Button 怎样接受用户点击并调用函数,具体方法名称是什么？

1. 主要是在UICamera脚本中用射线判断点击的物体并通过SendMessage调用OnClick() OnPress()等函数，可以说NGUI的按钮是通过发消息这个方式调用的。具体方法名称是OnClick()。

2. 事例代码：


```csharp
void Awake ()
{ 
    //获取需要监听的按钮对象
    GameObject button = GameObject.Find("UI Root/Button3");
    //设置这个按钮的监听，指向本类的ButtonClick方法中。
    UIEventListener.Get(button).onClick = OnButton3Click;
}
private void OnButton3Click(GameObject button)
{
    Debug.Log("我是按钮3被点击了");
}
```



#### itween 插件的作用是什么，itween 作用于世界坐标还是局部坐标，请列举出 3 个其常用方法？

iTween 是一个动画库，作者创建它的目的就是最小的投入实现最大的产出。让你做开发更轻松，用它可以轻松实现各种动画，晃动，旋转，移动，褪色，上色，控制音频等等方法：

a. MoveTo 物体移动；

b.ColorTo：随着时间改变对象的颜色组；

c. LookTo：随时间旋转物体让其脸部朝向所提供的 Vector3 或 Transform 位置；

官方文档：http://www.pixelplacement.com/itween/documentation.php



#### 去掉敏感字的程序

```csharp
String s = "你是坏蛋";
s.Replace("坏蛋", "**");
```



#### 写一个角色控制器，鼠标控制屏幕晃动，鼠标控制开枪

```csharp
public class Player : MonoBehaviour
{
    public GameObject _prefabBullet;
    private float _angleSpeed = 120f;
    void Update()
    {
        float eularY = Input.GetAxis("Mouse X") * _angleSpeed * Time.deltaTime;
        transform.Rotate(new Vector3(0, eularY, 0));
        if (Input.GetMouseButtonDown(0))
        {
            Instantiate(_prefabBullet, transform.position, transform.rotation);
        }
    }
}
```

**56、**需求：写一个角色控制器，鼠标控制屏幕晃动，鼠标控制开枪。敌人AI，有各种状态，实现各种状态之间的切换。敌人会和主角对抗，敌人被打到之后，会闪一次红色，然后红色比例提升10%，10次攻击之后，成红色。敌人会自动攻击主角，主角也会有颜色变化。敌人会在范围内巡逻。UI，左边显示8个AI的被攻击次数，右边显示AI的攻击次数排序。

```csharp
public class Player : MonoBehaviour
{
    public Camera _camera;
    public GameObject _prefabBullet;
    private float _angleSpeed = 120f;
    private int _life = 10; //生命值
    private bool _state = false; //玩家的状态
   
    public void IsState() //是否被打到
    {
        if (_state && _life > 0)
        {
            _life -= 1;
            _state = false;
        }
        else
        {
            _state = true;
        }
    }
    public void RoleRotate()
    {
        float eularY = Input.GetAxis("Mouse X") * _angleSpeed * Time.deltaTime;
    }
    //发射子弹
    public void RoleShoot()
    {
        if (Input.GetMouseButtonDown(0))
        {
            Instantiate(_prefabBullet, transform.position, transform.rotation);
        }
    }
}
public class Enemy : MonoBehaviour
{
    private bool _state = false; //敌人被打到状态
    private float _distance; //玩家与敌人距离
    public GameObject _role; //角色
    private int _life = 10; //生命值
    private int _timeAccack = 0; //敌人被攻击次数
   
    public void EnemyState() //敌人状态
    {
        if (_distance >= 10f)
        {
            if (_life >= 1 && _state == true)
            {
                _life -= 1;
                _timeAccack++;
            }
            _state = false;
        }
        else if (_distance >= 0 && _state == false)
        {
            _state = true;
        }
    }
    //敌人与玩家距离
    public void Distance()
    {
        _distance = Vector3.Distance(transform.position, _role.transform.position);
    }
    void OnGUI()
    {
        GUI.TextArea(new Rect(20, 50, 80, 30), _timeAccack.ToString());
        GUI.TextArea(new Rect(20, 90, 80, 30), _timeAccack.ToString());
        GUI.TextArea(new Rect(20, 130, 80, 30), _timeAccack.ToString());
    }
}
```



#### 3D空间有三个cube当做点，有一条鱼的模型，要求在三点之间游动，要求转向平滑一点，控制鱼的运动朝向（用四元数和欧拉角）

```C#
public class Test : MonoBehaviour
{
    public Transform[] waypoints; // 存储三个点的Transform
    public float movementSpeed = 2.0f;
    public float rotationSpeed = 5.0f;

    private int currentWaypointIndex = 0;

    void Update()
    {
        // 如果所有点都已经访问，重新从第一个点开始
        if (currentWaypointIndex >= waypoints.Length) currentWaypointIndex = 0;

        // 获取当前目标点的位置
        Vector3 targetPosition = waypoints[currentWaypointIndex].position;

        // 计算朝向目标点的方向
        Vector3 direction = targetPosition - transform.position;
        direction.y = 0; // 鱼只在水平面移动

        // 如果鱼未到达目标点，继续朝向目标点移动
        if (direction.magnitude > 0.1f) //返回该向量的长度
        {
            // 控制鱼的旋转朝向
            Quaternion targetRotation = Quaternion.LookRotation(direction);
            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);

            // 移动到目标点
            transform.Translate(Vector3.forward * movementSpeed * Time.deltaTime);
        }
        else // 如果到达了目标点，转到下一个点
        {
            currentWaypointIndex++;
        }
    }
}
```

