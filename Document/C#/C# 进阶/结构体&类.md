**引用类型总是从托管堆分配， C# 的 `new` 操作符返回对象内存地址 —— 即指向对象数据的内存地址**。使用引用类型必须留意性能问题。首先要认清楚以下四个事实。

1. **内存必须从托管堆分配。**
2. **堆上分配的每个对象都有一些额外成员，这些成员必须初始化。**
   - **对象头（Object Header）**：对象头包含了类型对象指针（Type Object Pointer），用于指向该对象的类型信息。对象头还可能包含一些用于垃圾收集和同步的标志位，比如锁定标志等。
   - **同步块索引（Sync Block Index）**：用于支持对象的同步功能。当对象被锁定时，CLR会在同步块索引中记录锁定对象的信息，以确保多线程环境下的正确同步。
   - **类型对象指针（Type Object Pointer）**：指向对象的类型信息。这使得CLR能够识别对象的类型，并在运行时执行类型检查和多态操作。
   - **扩展类型信息（Extended Type Information）**：包含了一些额外的类型信息，比如对象的哈希码、方法表等。
   - **数组长度（Array Length）**：对于数组对象而言，会包含数组的长度信息，以便在运行时进行边界检查
3. **对象中的其他字节(为字段而设)总是设为零。**
4. **从托管堆分配对象时，可能强制执行一次垃圾回收。**

**值类型的实例一般在线程栈上分配(虽然也可作为字段嵌入引用类型的对象中)**。在代表值类型实例的变量中不包含指向实例的指针。相反，变量中包含了实例本身的字段。由于变量已包含了实例的字段，所以操作实例中的字段不需要提领指针。值类型的实例不受垃圾回收器的控制。因此，**值类型的使用缓解了托管堆的压力，并减少了应用程序生存期内的垃圾回收次数**。

所有结构都是抽象类型 `System.ValueType` 的直接派生类。 `System.ValueType` 本身又直接从 `System.Object` 派生。根据定义，所有值类型都必须从 `System.ValueType` 派生。所有枚举都从 `System.Enum` 抽象类型派生，后者又从 `System.ValueType` 派生

虽然不能在定义值类型时为它选择基类型，但如果愿意，值类型可实现一个或多个接口。除此之外，所有值类型都隐式密封，目的是防止将值类型用作其他引用类型或值类型的基类型。例如，无法将 `Boolean`，`Char`，`Int32`，`UInt64`，`Single`，`Double`，`Decimal`等作为基类型来定义任何新类型。



以下代码和图 5-2 演示了引用类型和值类型的区别：

 ```C#
 // 引用类型(因为 'class')
 class SomeRef { public Int32 x; }

 // 值类型(因为 'struct')
 struct SomeVal { public Int32 x; }

 static void ValueTypeDemo()
 {
   SomeRef r1 = new SomeRef();  // 在堆上分配
   SomeVal v1 = new SomeVal();  // 在栈上分配
   rl.x = 5;                    // 提领指针
   v1.x = 5;                    // 在栈上修改
   Console.WriteLine(r1.x);     // 显示 “5”
   Console.WriteLine(v1.x);     // 同样显示 “5”
   // 下图 的左半部分反映了执行以上代码之后的情况

   SomeRef r2 = r1;             // 只复制引用(指针)
   SomeVal v2 = v1;             // 在栈上分配并复制成员
   rl.x = 8;                    // r1.x 和 r2.x 都会更改
   v1.x = 9;                    // v1.x 会更改， v2.x 不变
   Console.WriteLine(r1.x);     // 显示 "8"
   Console.WriteLine(r2.x);     // 显示 "8"
   Console.WriteLine(v1.x);     // 显示 "9"
   Console.WriteLine(v2.x);     // 显示 "5"
 }
 ```

![](E:\Gitee\Document\Texture\C#Plus\ClassStruct.jpg)  

图解代码执行时的内存分配情况  

上述代码中有这样一行：

```C#
SomeVal vl = new SomeVal();    // 在栈上分配
```

因为这行代码的写法，似乎是要在托管堆上分配一个 `SomeVal` 实例。但 C# 编译器知道 `SomeVal` 是值类型，所以会生成正确的 IL 代码，在线程栈上分配一个 `SomeVal` 实例。 C# 还会确保值类型中的所有字段都初始化为零。

上述代码还可以像下面这样写：

```C#
SomeVal v1;    // 在栈上分配 
```

这一行生成的 IL 代码也会在线程栈上分配实例，并将字段初始化为零。唯一的区别在于，如果使用 `new` 操作符，C# 会认为实例已初始化。以下代码更清楚地进行了说明：  

```C#
// 这两行代码能通过编译，因为 C# 认为 v1 的字段已初始化为 0
SomeVal v1 = new SomeVal();
Int32 a = v1.x;

// 这两行代码不能通过编译，因为 C# 不认为
// v1 的字段已初始化为 0
SomeVal v1；
Int32 a = v1.x;   // error CS0170：使用了可能未赋值的字段 “x” 
```

设计自己的类型时，要仔细考虑类型是否应该定义成值类型而不是引用类型。值类型有时能提供更好的性能。具体地说，除非满足以下全部条件，否则不应该将类型声明为值类型。

* **类型具有基元类型的行为。也就是说，是十分简单的类型，没有成员会修改类型的任何实例字段。如果类型没有提供会更改其字段的成员，就说该类型是不可变(immutable)类型。事实上，对于许多值类型，我们都建议将全部字段标记为 readonly(详情参见第 7 章 “常量和字段”)。**

* **类型不需要从其他任何类型继承。**

* **类型也不派生出其他任何类型**。

类型实例大小也应在考虑之列，因为实参默认以传值方式传递，造成对值类型实例中的字段进行复制，对性能造成损害。同样地，被定义为返回一个值类型的方法在返回时，实例中的字段会复制到调用者分配的内存中，对性能造成损害。所以，要将类型声明为值类型，除了要满足以上全部条件，还必须满足以下任意条件。

* **类型的实例较小(16 字节或更小)。**

* **类型的实例较大(大于 16 字节)，但不作为方法实参传递，也不从方法返回**。

值类型的主要优势是不作为对象在托管堆上分配。当然，与引用类型相比，值类型也存在自身的一些局限。下面列出了值类型和引用类型的一些区别。